/* global $vue HOST _ */
/* eslint prefer-promise-reject-errors: "error" */
import axios from 'axios'
import Vue from 'vue'
let $vue = new Vue()
// 动态加载API文件
let apiOption
if (process.env.NODE_ENV === 'production') {
  // './.production/'
  apiOption = Object.assign({}, ...(r => r.keys().map(key => r(key).default))(require.context('../../../../../src/api/', true, /\.js$/)))
} else {
  apiOption = Object.assign({}, ...(r => r.keys().map(key => r(key).default))(require.context('../../../../../src/api/', true, /\.js$/)))
}
// 全屏的等待,多个网络请求并发时,要等所有的请求都完成后,才隐藏全屏等待
// 所以全屏等待使用的是一个数字,当数字为0时,隐藏全屏等待
// Add a request interceptor
window.loading_count = 0
axios.interceptors.request.use(config => {
  // 等待提示
  if (config.loading) {
    // 等待数量+1
    config.loading.loading_count = config.loading.loading_count ? config.loading.loading_count + 1 : 1
    // elementUi等待提示
    config.loading.loading = config.loading.loading || $vue.$loading(config.loading)
  }
  // 全屏等待提示
  if (config.option && config.option.loading) {
    if (++window.loading_count > 0) window.loading = $vue.$loading({fullscreen: true})
  }
  $(window).trigger('requestInterceptors', config)
  return config
}, error => {
  return Promise.reject(error)
})
// Add a response interceptor
axios.interceptors.response.use(response => {
  // 等待提示
  hideLodding(response.config.loading)
  // 全屏等待提示
  if (response.config.option && response.config.option.loading) {
    if (--window.loading_count > 0) {
      window.loading.close()
    }
  }
  // 数据校验
  $(window).trigger('responseInterceptors', response)
  $(window).trigger('afterRequest', response)
  // 可以给一个接口设置缓存
  if (response.config.option && response.config.option.cache) {
    response.config.localOption[JSON.stringify(params)] = response
  }
  return response
}, err => {
  // 等待提示
  hideLodding(err.config && err.config.loading)
  // 错误的话,可能就不要等待提示了
  if (--window.loading_count <= 0) {
    window.loading_count = 0
    window.loading && window.loading.close()
  }
  $(window).trigger('errorRequest', err)
  // errNotify(error)
  return Promise.reject(err)
})
export default function api (url, params, dosome = {}) {
  if (!apiOption[url]) {
    throw new Error(`\napi无法找到url：\n${url}`)
  }
  let config = {
    host: apiOption[url].host || CONFIG.HOST,
    url: apiOption[url].url || url,
    method: apiOption[url].method || 'post',
    params: params,
    dosome: apiOption[url].dosome || dosome,
    _option: undefined,
    get option () {
      return this._option || apiOption[url]
    },
    set option (val) {
      this._option = val
    },
    cancel: false
  }
  $(window).trigger('beforeRequest', config)
  if (config.cancel) {
    return
  }
  if (config.option.cache && apiOption[url][JSON.stringify(params)]) {
    let res = apiOption[url][JSON.stringify(params)]
    try {
      $(window).trigger('afterRequest', res)
      return res
    } catch (e) {
      console.warn(url + '=>读取缓存时发生错误', e)
    }
  } else {
    return axios.request({
      method: config.method,
      url: config.host + config.url,
      data: ['put', 'post', 'patch'].indexOf(config.method) < 0 ? undefined : config.params,
      params: ['put', 'post', 'patch'].indexOf(config.method) > -1 ? undefined : config.params,
      option: config.option,
      headers: config.option.headers,
      localOption: apiOption[url],
      ...config.dosome
    })
  }
}
function hideLodding (loading) {
  if (!loading) return
  if (--loading.loading_count > 0) return
  loading.loading_count = 0
  // 关闭elementUI等待提示
  loading.loading && loading.loading.close()
  loading.loading = undefined
}
