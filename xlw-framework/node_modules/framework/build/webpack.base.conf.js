'use strict'
const path = require('path')
const fs = require('fs')
const utils = require('./utils')
const config = require('../config')
const vueLoaderConfig = require('./vue-loader.conf')
const srcConfig = require('../../../../src/config.js')
let entry = './src/main.js'
if (srcConfig.async && process.env.NODE_ENV === 'production') {
  setAsyncComponent()
  entry = './src/async.js'
}
function resolve (dir) {
  return path.join(__dirname, '../../../../', dir)
}
function resolveFramework (dir) {
  return path.join(__dirname, '..', dir)
}

module.exports = {
  context: path.resolve(__dirname, '../'),
  entry: {
    app: entry
  },
  output: {
    path: config.build.assetsRoot,
    filename: '[name].js',
    publicPath: process.env.NODE_ENV === 'production'
      ? config.build.assetsPublicPath
      : config.dev.assetsPublicPath
  },
  resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
    }
  },
  module: {
    rules: [
      ...(config.dev.useEslint? [{
        test: /\.(js|vue)$/,
        loader: 'eslint-loader',
        enforce: 'pre',
        include: [resolve('src'), resolve('test')],
        options: {
          formatter: require('eslint-friendly-formatter'),
          emitWarning: !config.dev.showEslintErrorsInOverlay
        }
      }] : []),
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [resolve('src'), resolve('test'), resolveFramework('src'), resolve('xlw-components')]
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
        }
      },
      // 需要打包的其他文件
      {
        test: /\.(wav|swf|exe)(\?.*)?$/,
        loader: 'file-loader',
        query: {
          limit: 2000,
          name: utils.assetsPath('other/[name].[hash:7].[ext]')
        }
      },
      // 不需要打包的其他文件
      {
        test: /\.(bat|md)(\?.*)?$/,
        loader: 'raw-loader'
      },
    ]
  }
}
function setAsyncComponent () {
  let currentPath = path.resolve('./')
  let utils ={
    async readDir (dirPath, regExp) {
      let result = []
      await readDir(dirPath, regExp)
      return result
      async function readDir(dirPath, regExp) {
        dirPath = path.resolve(dirPath)
        let files = await fs.readdirSync(dirPath)
        await Promise.all(files.map(async fileName => {
          let fileDir = path.join(dirPath , fileName)
          let stats = await fs.statSync(fileDir)
          let isFile = stats.isFile()
          let isDir = stats.isDirectory()
          if(isFile){
            result.push({
              path: fileDir,
              name: fileName
            })
          }
          if(isDir){
            await readDir(fileDir)
          }
        }))
      }
    }
  }
  start()
  async function start () {
    let pages = await readPages('src/pages')
    console.log(JSON.stringify(pages))
    let asyncText = await readAsyncFile('xlw-framework/node_modules/framework/src/async.js')
    let VueComponentStr = ''
    let components = await readComponents('src/components')
    let xlwComponents = await readComponents('xlw-components/node_modules')
    components.forEach(item => {
      let path = item.path.replace(/(^.+\\).+$/, '$1').replace(/\\/g, '\\\\')
      VueComponentStr += `Vue.component('t-${item.name}', loadComponent_components.bind(this, {name: '${item.name}', path: '${item.path}', components: ${JSON.stringify(item.components || [])}}))
      `
    })
    xlwComponents.forEach(item => {
      let path = item.path.replace(/(^.+\\).+$/, '$1').replace(/\\/g, '\\\\')
      VueComponentStr += `Vue.component('t-${item.name}', loadComponent_xlwComponents.bind(this, {name: '${item.name}', path: '${item.path}', components: ${JSON.stringify(item.components || [])}}))
      `
    })
    asyncText = asyncText.replace(/\/\*replace\*\/[\s\S]*\/\*replace\*\//g, '/*replace*/let pages=' + JSON.stringify(pages) + '\n' + VueComponentStr + '/*replace*/')
    fs.writeFileSync('xlw-framework/node_modules/framework/src/async.js', asyncText)
  }
  async function readComponents (path) {
    let files = await utils.readDir(path)
    files.forEach(item => item.path = item.path.replace(currentPath, '').replace(/\\/g, '/'))
    let components = files.filter(item => item.name.match(/^component\..+\.vue$/)).map(item => {
      item.name = item.name.replace(/^component\.(.+)\.index\.vue$/, '$1')
      return item
    })
    // 要判断页面中是否子组件
    hasComponents(files, components)
    return components
  }
  async function readPages (path) {
    let files = await utils.readDir(path)
    files.forEach(item => item.path = item.path.replace(currentPath, '').replace(/\\/g, '/'))
    // 获取到所有页面了
    let pages = files.filter(item => item.name.match(/^page\..+\.vue$/)).map(item => {
      item.name = item.name.replace(/^page\.(.+)\.index\.vue$/, '$1')
      return item
    })
    // 要判断页面中是否还有子路由
    hasChildren(files, pages)
    // 要判断页面中是否有组件
    hasComponents(files, pages)
    return pages
  }
  async function readAsyncFile (path) {
    return await fs.readFileSync(path, 'utf-8')
  }
  async function hasChildren (files, result) {
    let childrens = files.filter(item => item.path.indexOf('\/childrens\/') > 0 && item.name.match(/\.vue$/))
    result.forEach(item => {
      let itemPath = item.path.replace(/(^.+\/).+$/, '$1')
      let myChildrens = childrens.filter(children => children.path.replace(/(^.+\/).+$/, '$1').match(new RegExp(itemPath + 'childrens/.+$')))
      myChildrens.forEach(children => {
        // 包含关系，那么它们是父页面与子页面的关系
        let childrenPath = children.path.replace(/(^.+\/).+$/, '$1')
        if (itemPath !== childrenPath && childrenPath.indexOf(itemPath) > -1) {
          item.childrens = item.childrens || []
          item.childrens.push(children)
          hasChildren(files, [children])
        }
      })
    })
  }
  async function hasComponents (files, result) {
    let components = files.filter(item => item.path.indexOf('\/components\/') > 0 && item.name.match(/\.vue$/))
    result.forEach(item => {
      let itemPath = item.path.replace(/(^.+\/).+$/, '$1')
      let myComponents = components.filter(component => component.path.replace(/(^.+\/).+$/, '$1').match(new RegExp(itemPath + 'components/.+$')))
      myComponents.forEach(component => {
        // 包含关系，那么它们是父组件与子组件的关系
        let componentnPath = component.path.replace(/(^.+\/).+$/, '$1')
        if (itemPath !== componentnPath && componentnPath.indexOf(itemPath) > -1) {
          item.components = item.components || []
          item.components.push(component)
          hasChildren(files, [component])
        }
      })
    })
  }
}
